import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as n,c as s,f as e}from"./app-7fdc7960.js";const t={},p=e(`<h1 id="线程-thread" tabindex="-1"><a class="header-anchor" href="#线程-thread" aria-hidden="true">#</a> 线程（Thread）</h1><p>线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一个进程可以由很多个线程组成，线程间共享进程的所有资源，每个线程有自己的堆栈和局部变量。线程由 CPU 独立调度执行，在多 CPU 环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理。</p><p>很多人把线程和进程放到一起做对比，然而实际上，线程和进程并不是处于同一层级下。线程是CPU调度的概念，表示的一条执行路径，CPU一个核执行函数，那么这就是一个线程。而进程是操作系统管理内存和执行单元的概念，表示的是一片独立的内存空间，一个进程可以包含多个线程，多个线程共享进程的内存空间。</p><h2 id="线程的用途" tabindex="-1"><a class="header-anchor" href="#线程的用途" aria-hidden="true">#</a> 线程的用途</h2><p>线程的出现是为了解决多任务处理中的一些问题，比如说：</p><ul><li>如何在下载文件的同时，还能快速响应UI界面？</li><li>如何利用多核资源，快速处理大量计算任务？</li><li>如何同时处理多个网络请求，提高用户体验？</li></ul><p>多任务处理时，分线程来处理不同的任务，可以提高程序的运行效率，同时也能提高用户体验。</p><h2 id="线程的使用" tabindex="-1"><a class="header-anchor" href="#线程的使用" aria-hidden="true">#</a> 线程的使用</h2><p>我们这里主要介绍一下Linux下pthread线程库的使用。这是一个POSIX标准的线程库，被广泛应用于Linux, Unix, MacOS等系统中。</p><h3 id="创建新线程" tabindex="-1"><a class="header-anchor" href="#创建新线程" aria-hidden="true">#</a> 创建新线程</h3><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">pthread_create</span> <span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>thread<span class="token punctuation">,</span><span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>thread 是线程标识符，但这个参数不是由用户指定的，而是由 pthread_create 函数在创建时将新的线程的标识符放到这个变量中。</li><li>attr 指定线程的属性，可以用 NULL 表示默认属性。</li><li>start_routine 指定线程开始运行的函数。</li><li>arg 是 start_routine 所需要的参数，是一个无类型指针。</li></ul><p>若创建成功，返回0；若出错，则返回错误编号。</p><h3 id="结束线程" tabindex="-1"><a class="header-anchor" href="#结束线程" aria-hidden="true">#</a> 结束线程</h3><p>当发生以下情形之一时，线程就会结束：</p><ul><li>线程运行的函数return了，也就是线程的任务已经完成；</li><li>线程调用了 pthread_exit 函数；</li><li>其他线程调用 pthread_cancel 结束这个线程；</li><li>进程调用 exec() 或 exit()，结束了；</li><li>main() 函数先结束了，而且 main() 自己没有调用 pthread_exit 来等所有线程完成任务。</li></ul><p>主线程一般会使用 pthread_join 函数来等待子线程结束，这样可以保证主线程在子线程结束之后再结束，否则主线程结束了，子线程也会被强制结束。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">pthread_join</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>thread 是线程标识符，指定要等待的线程。</li><li>retval 是一个无类型指针，线程结束时的返回值会赋给这个地址。</li></ul><p>若成功，返回0；若出错，则返回错误编号。</p><p>用户线程可以调用 pthread_exit 函数来结束自己的线程，这个函数的作用和 return 一样，只是 return 是返回到调用者，而 pthread_exit 是直接结束线程。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">pthread_exit</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>retval 是由用户指定的参数， pthread_exit 完成之后可以通过这个参数获得线程的退出状态。</p><p>主线程也可以调用 pthread_cancel 函数来强制结束子线程，这个函数的作用是向子线程发送一个取消请求，子线程会在合适的时候结束。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">pthread_cancel</span> <span class="token punctuation">(</span><span class="token class-name">pthread_t</span> thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,25),i=[p];function c(l,o){return n(),s("div",null,i)}const u=a(t,[["render",c],["__file","(1)线程.html.vue"]]);export{u as default};
