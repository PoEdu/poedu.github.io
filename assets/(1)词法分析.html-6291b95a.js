import{_ as u}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as p,c as v,a as i,w as d,d as e,e as n,f as o}from"./app-7fdc7960.js";const h={},m=o(`<h1 id="词法分析-lexical-analysis" tabindex="-1"><a class="header-anchor" href="#词法分析-lexical-analysis" aria-hidden="true">#</a> 词法分析（Lexical Analysis）</h1><p>词法分析是编译器工作的第一步，负责读取字符串，转换为一个个的 Token，供语法分析使用。</p><p>那么什么是Token呢？Token是编译器识别出来的一个个的词法单元，就像句子里面的单词一样，比如：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个C语句，一种直观的切分方法是：</p>`,5),_=e("p",null,[n("这样做的好处是，我们尽量将有用的信息提取出来，并且划分成词，分成大类，这样语法分析的时候，就可以自然地使用这些词，而不用去想每次读一个字符，下个字符是什么。 归类的好处是明显的，比如"),e("code",null,"1"),n("这个token，无论数字是多少，在语法分析器眼里，这个地方就是一个数字而已，不用去关心细节的内容。")],-1),E=e("h2",{id:"词法分析的过程",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#词法分析的过程","aria-hidden":"true"},"#"),n(" 词法分析的过程")],-1),b=e("p",null,"词法分析的过程，从宏观上来讲，是一个将文件读取成字符串，然后再输出成token序列的过程。这个过程可以有两种实现方式，一种是完整读入，然后输出完整的token序列。另外一种是按需获取，类似一个迭代器，每次调用，都返回下一个token，直到文件结束。一般我们为了节约内存，提升性能，往往会采取第二种按需读取的方式。这对于较大文件的处理是非常有必要的。",-1),k=e("p",null,"按需读取，则引入了一些较为复杂的问题，比如文件按需加载，这时就需要将文件分块，需要考虑到文件的边界问题，比如一个token可能跨越两个文件块，这时就需要将两个文件块合并成一个token，这就需要在文件块的边界做一些特殊处理。对于这种模式的词法分析，有时还会因为难以获取上下文，而导致无法轻松打印异常信息。这两个问题我们可以留到单独一节来讨论。",-1),A=e("h2",{id:"词法的表示",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#词法的表示","aria-hidden":"true"},"#"),n(" 词法的表示")],-1),f=e("p",null,[n("词法一般是使用正则表达式进行表示的，比如标识符的正则表达式为："),e("code",null,"[a-zA-Z_][a-zA-Z0-9_]*")],-1),x=o(`<h2 id="常见的token划分方法" tabindex="-1"><a class="header-anchor" href="#常见的token划分方法" aria-hidden="true">#</a> 常见的Token划分方法</h2><p>一个典型的编程语言词法，往往包含几个大类：</p><ol><li>标识符（identifier）</li></ol><p>大多数编程语言都运行用户定义各种符号，如变量名，函数名，类型名等等，这种一般被称为标识符（indentifier）。这些符号让用户随便取名，方便开发时使用。 典型的C语言标识符可以用正则表达式表示为：<code>[a-zA-Z_][a-zA-Z0-9_]*</code>，也就是以字母或下划线开头，后面跟着字母、数字或下划线组成的字符串。</p><ol start="2"><li>关键字（keyword）</li></ol><p>保留字是编程语言中，被语言本身保留的一些标识符，这些标识符有特殊的含义，不能被用户定义，比如C语言中的，<code>if</code>，<code>while</code>等等。大多数语言的关键字是固定的，这方便了词法分析器的设计，但有一些特殊情况，也可以允许用户自定义关键字，这种时候一般就需要先把所有关键字当做标识符来处理，词法分析器在识别到标识符的时候，再去查表，判断是否是关键字。</p><ol start="3"><li>数字</li></ol><p>一般编程语言都会有许多种不同形式的数字，进行数学运算和表达式运算往往是编程语言的重要功能，所以数字的识别是词法分析器的重要部分。</p><ol start="4"><li>字符串</li></ol><p>字符串处理在很多程序中也相当常见，单引号或双引号括起来的一串字符，就是字符串，比如<code>&quot;hello world&quot;</code>，<code>&#39;a&#39;</code>，<code>&quot;123&quot;</code>等等。这里要尤其注意字符串的表达能力，为了表示字符串中的引号，特殊符号等，转义往往是字符串需要原生支持的功能。</p><ol start="5"><li>注释</li></ol><p>准确的来说，注释一般不算做token，我们在把注释识别之后往往直接丢弃，对于语法分析器来说，注释是没有意义的，但是注释的识别是词法分析器的重要部分，因为注释的存在，会影响到后面的token的识别。</p><ol start="6"><li>空白符</li></ol><p>空白符是词法分析中另外一种需要丢弃的符号，但其往往用来分隔其他的token，比如分割两个标识符。</p><ol start="7"><li>运算符</li></ol><p>一元运算符表示对某个表达式的操作，比如<code>*</code>, <code>!</code>，<code>~</code>，<code>++</code>，<code>--</code>等等。各种数学运算和逻辑运算都需要二元运算符，比如<code>+</code>，<code>-</code>，<code>*</code>，<code>/</code>，<code>&amp;&amp;</code>，<code>||</code>等等。有些符号既是一元运算符，也是二元的，那么我们在词法分析的时候，一般不做区分，把其统称运算符，等到语法分析层面时再根据上下文来进行判断。</p><h2 id="词法分析的实现" tabindex="-1"><a class="header-anchor" href="#词法分析的实现" aria-hidden="true">#</a> 词法分析的实现</h2><h3 id="手工编写的词法分析器" tabindex="-1"><a class="header-anchor" href="#手工编写的词法分析器" aria-hidden="true">#</a> 手工编写的词法分析器</h3><p>尽管目前有很多自动的词法分析生成工具，但很多情况下手工编写的词法分析器依旧很有用，因为可以更加灵活的处理一些特殊情况，尤其是提供更好的异常处理，以及能把一些typo的错误识别出来。 手工编写词法分析器的方式并不困难，主要就是用代码来编写该如何识别词法。</p><p>比如，如果我们想切分出字符串来，那么可以写一个函数：</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>enum TokenID {
    Unknown,
    StringT,
    ...
}

struct Token {
    TokenID ID;
    string data;
};

Token scanString(const char*&amp; input) {
    string data;
    assert(*input == &#39;&quot;&#39;);
    ++input;
    while (*input != &#39;&quot;&#39;)
        if (*input != &#39;\\\\&#39;) {
            ++input; 
            data += *input;
        } else {
            input+=2;
            data += escape(*(input-1));
        }
    ++input;
    return {StringT, data};
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>整个词法分析器可能是在一个大的switch里面:</p><div class="language-c++ line-numbers-mode" data-ext="c++"><pre class="language-c++"><code>Token getNextToken(const char*&amp; input) {
    
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="自动生成词法分析器" tabindex="-1"><a class="header-anchor" href="#自动生成词法分析器" aria-hidden="true">#</a> 自动生成词法分析器</h3><p>自动生成词法分析器的工具有很多，比如flex，lex，antlr等等。这些工具都是根据一定的规则，自动生成词法分析器的代码，这样就可以省去手工编写的过程。</p>`,25),g=e("p",null,"自动生成词法分析器是一个相对复杂的过程，核心思路是，使用一系列有优先级的正则表达式来描述每个词法，然后词法分析器会根据这个列表进行匹配，选择最长，最高优先级的匹配结果。而每个正则式匹配后，都可以触发对应的动作，从而可以用来生成一个对应的token。",-1),B=e("p",null,"整个流程可以简单描述为四步：",-1),F=e("ol",null,[e("li",null,"正则表达式的识别"),e("li",null,"构造自动机"),e("li",null,"优化自动机"),e("li",null,"生成代码")],-1),T=e("p",null,"对于正则表达式的识别，我们可以用手工编写的方式，也可以使用其他自动生成的工具，比如flex。首先将正则表达式转换为可以识别的语法树，然后再进行处理。",-1),C=e("p",null,"对于自动机的构造，这里有两条不同的技术路线，一种是先构造NFA，再将NFA转换为DFA。另外一种方式是更为紧凑的直接构造DFA的方法。两种思路上其实是一致的，只是实现方式上看是否保留有中间临时数据(NFA)。",-1);function w(y,D){const t=l("Mermaid"),c=l("Lexer"),s=l("ClientOnly"),a=l("RouterLink"),r=l("Regex");return p(),v("div",null,[m,i(t,{id:"mermaid-13",code:"eJzT1dXlKsksyUm1Unja0f60o+3phL7ns1pC8rNT857u6n/aMZ0LpCQtJ788OSOxqETBJ4hLAQhKQAqilayVYsHczLwSBV1dO4VEMGkLJg3BJFghFxcAN+Eibg=="}),_,i(s,null,{default:d(()=>[i(c)]),_:1}),E,b,k,A,f,e("p",null,[n("如果您之前没有了解过正则表达式，那么推荐您先阅读 "),i(a,{to:"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1.%E5%89%8D%E7%AB%AF/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"},{default:d(()=>[n("正则表达式")]),_:1}),n(" 一章。")]),i(s,null,{default:d(()=>[i(r)]),_:1}),x,e("p",null,[n("如果你想了解flex可使用方法，那么可以参考 "),i(a,{to:"/%E6%9E%81%E9%80%9F%E6%95%99%E7%A8%8B/flex.html"},{default:d(()=>[n("极速教程-flex")]),_:1})]),g,e("p",null,[n("词法分析器在实现上，一般是使用确定有限自动机来完成功能的，这样可以保证分析器的性能。如果您之前没有了解过自动机，可以参考 "),i(a,{to:"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/1.%E5%89%8D%E7%AB%AF/%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90/%E8%87%AA%E5%8A%A8%E6%9C%BA%E7%90%86%E8%AE%BA.html"},{default:d(()=>[n("自动机理论")]),_:1}),n(" 一章。")]),B,F,T,C])}const q=u(h,[["render",w],["__file","(1)词法分析.html.vue"]]);export{q as default};
