import{_ as e}from"./plugin-vue_export-helper-c27b6911.js";import{o as t,c as i,f as r}from"./app-7fdc7960.js";const a={},o=r('<h1 id="运行时内存布局-runtime-memory-layout" tabindex="-1"><a class="header-anchor" href="#运行时内存布局-runtime-memory-layout" aria-hidden="true">#</a> 运行时内存布局（Runtime Memory Layout）</h1><p>运行时内存的布局直接影响着我们如何生成代码，如何调试程序，更影响着我们生成代码的质量。因此，我们有必要深入了解一下运行时内存的布局。</p><p>现代操作系统的一大特点就是大量应用进程作为程序的执行单元。我们每个程序都拥有独立的虚拟地址空间，这使得本程序在运行时，不会和其他进程相互干扰。这种抽象的实现是通过操作系统的虚拟内存机制来完成的，这也大大简化了我们程序生成的难度。</p><h2 id="内存布局" tabindex="-1"><a class="header-anchor" href="#内存布局" aria-hidden="true">#</a> 内存布局</h2><p>我们的程序在运行时，会被加载到内存中，这个时候，我们的程序会被分为几个部分：</p><ul><li>代码段：存放我们的代码</li><li>数据段：存放我们的全局变量、常量、静态变量等。分为文字常量区、初始化数据区、未初始化数据区</li><li>堆：存放我们的动态分配的内存</li><li>栈：存放我们的局部变量、函数参数、返回值等</li><li>内核空间：存放操作系统的内核代码和数据，各个进程共享</li><li>共享内存映射：存放我们的共享内存映射区域，可根据配置来实现进程内存共享</li></ul><p>而整个虚拟内存，则是由操作系统的<strong>多级页表</strong>来实现的。每个进程都有自己独立的页表，用来记录，虚拟内存空间的哪些部分被映射到了物理内存中。这样，我们的程序就可以使用虚拟内存，而不用关心物理内存的具体情况。而多级页表可以被MMU（内存管理单元）所支持，通过高效的硬件缓存结构，使得虚拟内存的访问速度和物理内存的访问速度相差没有很大。</p>',7),l=[o];function _(n,c){return t(),i("div",null,l)}const h=e(a,[["render",_],["__file","(1)运行时内存布局.html.vue"]]);export{h as default};
