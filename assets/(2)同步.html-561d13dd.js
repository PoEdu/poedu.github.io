import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as r,f as i}from"./app-7fdc7960.js";const h={},n=i('<h1 id="同步-synchronization" tabindex="-1"><a class="header-anchor" href="#同步-synchronization" aria-hidden="true">#</a> 同步（Synchronization）</h1><h2 id="互斥锁-mutex" tabindex="-1"><a class="header-anchor" href="#互斥锁-mutex" aria-hidden="true">#</a> 互斥锁(Mutex)</h2><p>Mutex 常常被用来保护那些可以被多个线程访问的共享资源，比如可以防止多个线程同时更新同一个数据时出现混乱。</p><h2 id="条件变量-condition-variable" tabindex="-1"><a class="header-anchor" href="#条件变量-condition-variable" aria-hidden="true">#</a> 条件变量(Condition Variable)</h2><p>互斥锁只有两种状态，这限制了它的用途。条件变量则允许线程在阻塞的时候等待另一个线程发送的信号，当收到信号后，阻塞的线程就被唤醒并试图锁定与之相关的互斥锁。条件变量常常要和互斥锁结合使用。</p><h2 id="信号量-semaphore" tabindex="-1"><a class="header-anchor" href="#信号量-semaphore" aria-hidden="true">#</a> 信号量(Semaphore)</h2><p>信号量说起来非常繁琐，但本质很简单，你可以认为它给每个线程都分配了一把钥匙，当线程想要访问某个资源时，必须先得到这把钥匙，如果钥匙已经被其他线程拿走了，那么线程就必须等待，直到钥匙被释放出来。</p><h2 id="读写锁-read-write-lock" tabindex="-1"><a class="header-anchor" href="#读写锁-read-write-lock" aria-hidden="true">#</a> 读写锁(Read-Write Lock)</h2><p>读写锁是一种特殊的互斥锁，它把对共享资源的访问者划分成读者和写者，读者只对资源进行读访问，写者则需要对资源进行写操作。当一个线程占用写锁时，其他线程不能对该锁进行加锁操作，这和互斥锁的行为是一致的。但是当一个线程占用读锁时，其他线程也可以对该资源加读锁，而不能加写锁。这样就实现了多个线程对该资源的并发访问，读者线程之间不会发生冲突，读者和写者之间也会发生冲突，这也就是读写锁的特性。</p><h2 id="自旋锁-spinlock" tabindex="-1"><a class="header-anchor" href="#自旋锁-spinlock" aria-hidden="true">#</a> 自旋锁(Spinlock)</h2><p>自旋锁是一种比较特殊的锁，它不是将线程阻塞，而是让线程处于忙等的状态，当线程尝试获取锁时，如果锁已经被其他线程占用，那么该线程将处于忙等状态，一直等到锁被释放为止。自旋锁适用于锁使用者保持锁时间比较短的情况，如果是长时间占用，那么自旋锁将白白浪费 CPU 时间。</p><h2 id="屏障-barrier" tabindex="-1"><a class="header-anchor" href="#屏障-barrier" aria-hidden="true">#</a> 屏障(Barrier)</h2><p>屏障是一种同步机制，它允许多个线程在某个点上进行同步。当一个线程到达屏障点时，它将被阻塞，直到所有线程都到达了屏障点，所有线程才会继续执行。</p>',13),d=[n];function t(o,c){return e(),r("div",null,d)}const p=a(h,[["render",t],["__file","(2)同步.html.vue"]]);export{p as default};
