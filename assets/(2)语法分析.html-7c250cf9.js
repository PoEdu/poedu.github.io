import{_ as s}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as t,c as i,a as l,f as a}from"./app-7fdc7960.js";const r={},d=a(`<h1 id="语法分析-parsing" tabindex="-1"><a class="header-anchor" href="#语法分析-parsing" aria-hidden="true">#</a> 语法分析（Parsing）</h1><p>语法分析是编译器前端分析的核心，它的任务是根据词法分析得到的词法单元序列，构造语法分析树或语法分析树的翻译，同时进行语法错误检查。一个编程语言，语法规则的识别就是在这个模块中完成的。</p><h2 id="语法树" tabindex="-1"><a class="header-anchor" href="#语法树" aria-hidden="true">#</a> 语法树</h2><p>我们在写编程语言时，会发现很多代码都是嵌套结构的，比如类下面有函数，函数下面有语句，语句里面套表达式，表达式里面有函数调用，函数调用下面有参数，等等。</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World, %s!&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>语法树就是用多叉树结构将语法按层次表示出来，比如上面的代码，我们可以表示为：</p>`,6),c=a(`<p>我们在进行语法分析的时候，就在构造这样的语法树。</p><h2 id="语法规则的描述" tabindex="-1"><a class="header-anchor" href="#语法规则的描述" aria-hidden="true">#</a> 语法规则的描述</h2><p>首先遇到的问题是，我们应该如何描述一个编程语义的语法？经典的方式是使用BNF（巴科斯范式）或者EBNF（扩展巴科斯范式）来描述。比如我们可以用下面的EBNF来描述一个简单的四则运算的语法：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>&lt;expression&gt; ::= &lt;term&gt; { &lt;addop&gt; &lt;term&gt; }
&lt;addop&gt;      ::= + | -
&lt;term&gt;       ::= &lt;factor&gt; { &lt;mulop&gt; &lt;factor&gt; }
&lt;mulop&gt;      ::= * | /
&lt;factor&gt;     ::= ( &lt;expression&gt; ) | Number
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这边，我们一般把BNF中的符号划分为两种：<strong>终结符</strong> 与 <strong>非终结符</strong></p><p><code>&lt;ClientOnly&gt;&lt;ParseTree /&gt;&lt;/ClientOnly&gt;</code></p><h2 id="什么是语法分析" tabindex="-1"><a class="header-anchor" href="#什么是语法分析" aria-hidden="true">#</a> 什么是语法分析</h2><p>语法分析方法，根据分析的顺序，大多数都可以划分为两大类方法：</p><ol><li>自顶向下分析 - 从语法树的根节点开始，逐步向下伸展叶子节点，并完成整个语法树的分析</li><li>自底向上分析 - 从语法树的叶子节点开始，合并规约形成子树，逐渐合并成整颗语法树</li></ol><h2 id="自顶向下分析法-ll" tabindex="-1"><a class="header-anchor" href="#自顶向下分析法-ll" aria-hidden="true">#</a> 自顶向下分析法（LL）</h2><p>自顶向下分析很多时候也叫做预测分析，因为它的分析过程是根据当前的输入符号，预测下一个可能的语法单元，然后根据这个预测的语法单元，继续向下分析，直到分析完成。</p><h2 id="自底向上分析法-lr" tabindex="-1"><a class="header-anchor" href="#自底向上分析法-lr" aria-hidden="true">#</a> 自底向上分析法（LR）</h2><p>自顶向上分析法，也叫做移进归约分析法，它的分析过程是从输入符号串的左端开始，逐步向右扫描，将符号串中的一段符号归约为一个非终结符号，直到整个符号串归约为文法的开始符号。</p><h2 id="语法分析的实现" tabindex="-1"><a class="header-anchor" href="#语法分析的实现" aria-hidden="true">#</a> 语法分析的实现</h2><h3 id="手工实现递归下降分析器" tabindex="-1"><a class="header-anchor" href="#手工实现递归下降分析器" aria-hidden="true">#</a> 手工实现递归下降分析器</h3><p>手工实现一个递归下降分析器，其实就是手工实现预测分析的过程，我们首先写出LL(1)文法，然后根据预测结果，递归调用每个文法的分析函数。</p><h3 id="使用工具生成语法分析器" tabindex="-1"><a class="header-anchor" href="#使用工具生成语法分析器" aria-hidden="true">#</a> 使用工具生成语法分析器</h3><p>手工实现语法分析器，虽然可以让我们更好的理解语法分析的过程，但是对于复杂的语法，手工实现的过程也是非常繁琐的。所以我们一般会使用工具来生成语法分析器。LR(1) 文法采用规约的方式，由不同状态进行匹配，在可以规约的时候则规约成为新的语法树，这非常适合工具自动生成。</p>`,18);function o(p,u){const n=e("Mermaid");return t(),i("div",null,[d,l(n,{id:"mermaid-16",code:"eJxdkMFuwyAMhu99Cs6T+gSTdtkOe4BJO1gcvMQ0SAQizNbl7YsNTZPm4Njfb34bLhmXyXx9vJ5M/a4DwHVKgd4DMltrzuc3o3mXFXxSCOk75TDu6U8aVwCJ1iqXVBX3G6uvxOJT7KqUqv4l33w2wrjqiCNdMOPMAO3/7CJJ2+A+R+f3tnZGG0dyADX4SF2shSplXQiGFLmYYcL8clQjzrSN3K7mXd3IO8MFC80US/esXPVqN3rZ5kClG0Di7oiUqtL/kgEkEvPjwQQ0T4ABQ+i4P072sbgd4FLJZQciyA3s6QaaqJXA"}),c])}const v=s(r,[["render",o],["__file","(2)语法分析.html.vue"]]);export{v as default};
