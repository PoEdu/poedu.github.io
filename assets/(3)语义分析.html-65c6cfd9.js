import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{o as a,c as s,f as t}from"./app-7fdc7960.js";const e={},p=t(`<h1 id="语义分析-semantic-analysis" tabindex="-1"><a class="header-anchor" href="#语义分析-semantic-analysis" aria-hidden="true">#</a> 语义分析（Semantic Analysis）</h1><p>什么是语义分析呢？我们来看看如果从语法层看下面两段代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World, %s!&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以及</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> printf<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Hello World, %s!&quot;</span><span class="token punctuation">,</span> sayHello<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们会发现我们明显看不懂下面这段代码在干什么，当然，因为这是我乱写的。</p><p>我们可以看到，这两段代码的语法都是正确的，但是第二段代码的语义是错误的，因为我们在第二段代码中，把<code>printf</code>当做了一个参数名，而不是一个函数，<code>sayHello</code>明明是函数名，却又被当成了参数。检查语法树的内容是否符合语义，这就是语义分析的工作。</p><h2 id="符号" tabindex="-1"><a class="header-anchor" href="#符号" aria-hidden="true">#</a> 符号</h2><p>在语义分析中，我们核心要处理的就是<strong>符号</strong>。那么什么是符号呢？你可以简单把代码中，所有你能自己定义名字的东西都理解成是符号，比如变量名、函数名、类名、结构体名、枚举名、宏名等等。这些都是符号。我们在语义分析中，要做的就是检查这些符号是否符合语义。比如，我们在上面的例子中，<code>printf</code>是一个函数，而不是一个变量，所以我们在语义分析中，就需要做相应的检查。</p><h2 id="符号表" tabindex="-1"><a class="header-anchor" href="#符号表" aria-hidden="true">#</a> 符号表</h2><h3 id="符号表的作用" tabindex="-1"><a class="header-anchor" href="#符号表的作用" aria-hidden="true">#</a> 符号表的作用</h3><p>语义检查的核心，主要依靠的是符号表。符号表是一个存储符号信息的数据结构，我们可以把符号表看成是一个字典，存储着每个符号的信息。符号表的作用是，当我们遇到一个符号的时候，我们可以通过符号表来查找这个符号的信息。根据上下文环境，来判断这个符号是否符合语义。</p><p>比如，我们在处理函数的参数时，就可以把参数名和参数类型存储到符号表中，在下面处理时就可以使用符号表来判断这个符号是否符合语义。</p><table><thead><tr><th>符号名</th><th>符号类型</th><th>类型信息</th></tr></thead><tbody><tr><td>name</td><td>type define</td><td>char*</td></tr><tr><td>printf</td><td>function define</td><td>void(const char*, ...)</td></tr><tr><td>sayHello</td><td>function define</td><td>void(const char*)</td></tr></tbody></table><h3 id="级联符号表" tabindex="-1"><a class="header-anchor" href="#级联符号表" aria-hidden="true">#</a> 级联符号表</h3><p>在实际的编译器中，我们会使用级联符号表来存储符号信息。什么是级联符号表呢？我们来看下面的代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Name: %s\\n&quot;</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;Age: %d\\n&quot;</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以看到，我们会定义局部变量，而如果全局变量和局部变量重名的话，我们就需要使用符号表来区分这两个符号。我们可以使用一个符号表来存储全局变量，使用另一个符号表来存储局部变量。这样，我们就可以通过符号表来区分这两个符号了。</p><p>级联符号表很好的解决了这个问题，我们每个符号表都有一个父级符号表，当我们在当前符号表中找不到符号的时候，我们就会去父级符号表中查找。这样局部变量全部处理完后，我们就可以把局部符号表销毁，而不会影响到全局符号表。</p><p>全局符号表</p><table><thead><tr><th>符号名</th><th>符号类型</th><th>类型信息</th></tr></thead><tbody><tr><td>printf</td><td>function define</td><td>void(const char*, ...)</td></tr><tr><td>sayHello</td><td>function define</td><td>void(const char*)</td></tr></tbody></table><p>第一层：函数符号表</p><table><thead><tr><th>符号名</th><th>符号类型</th><th>类型信息</th></tr></thead><tbody><tr><td>name</td><td>type define</td><td>char*</td></tr></tbody></table><p>第二层：if语句符号表</p><table><thead><tr><th>符号名</th><th>符号类型</th><th>类型信息</th></tr></thead><tbody><tr><td>age</td><td>type define</td><td>int</td></tr></tbody></table><p>如果有更多层嵌套，则可以继续添加更多层，整个符号表以栈的方式工作，进入一个作用域时创建，退出的时候，就可以把这个符号表销毁。</p>`,26),o=[p];function c(i,d){return a(),s("div",null,o)}const u=n(e,[["render",c],["__file","(3)语义分析.html.vue"]]);export{u as default};
