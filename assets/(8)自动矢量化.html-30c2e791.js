import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o,c as e,d as a,e as n,a as c,w as l,f as i}from"./app-7fdc7960.js";const u={},r=a("h1",{id:"自动矢量化-auto-vectorization",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#自动矢量化-auto-vectorization","aria-hidden":"true"},"#"),n(" 自动矢量化（Auto-vectorization）")],-1),k=a("p",null,"自动矢量化是一种重要的优化技术，它可以将一些循环中的标量操作转换为矢量操作，从而提高程序的性能。在本节中，我们将介绍自动矢量化的基本原理和实现方法。",-1),d=i(`<h2 id="什么是矢量化操作" tabindex="-1"><a class="header-anchor" href="#什么是矢量化操作" aria-hidden="true">#</a> 什么是矢量化操作</h2><p>CPU中的SIMD指令集是一种单指令多数据的并行计算模式，它可以同时对多个数据进行相同的操作。例如，SSE指令集中的<code>_mm_add_ps</code>函数可以同时对4个单精度浮点数进行加法运算。如果我们有一个循环，每次迭代都对一个数组中的元素进行加法操作，那么我们就可以将这个循环转换为矢量操作，从而提高程序的性能。</p><p>例如，下面的C语言代码对一个数组中的元素进行加法操作：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    c<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可以将这个循环转换为矢量操作：</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">float</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>b<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">+=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    __m128 va <span class="token operator">=</span> <span class="token function">_mm_load_ps</span><span class="token punctuation">(</span>a<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    __m128 vb <span class="token operator">=</span> <span class="token function">_mm_load_ps</span><span class="token punctuation">(</span>b<span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    __m128 vc <span class="token operator">=</span> <span class="token function">_mm_add_ps</span><span class="token punctuation">(</span>va<span class="token punctuation">,</span> vb<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">_mm_store_ps</span><span class="token punctuation">(</span>c<span class="token operator">+</span>i<span class="token punctuation">,</span> vc<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样，每条指令同时操作4个元素，大幅提高了硬件的利用率和程序效率。</p><h2 id="自动矢量化的基本原理" tabindex="-1"><a class="header-anchor" href="#自动矢量化的基本原理" aria-hidden="true">#</a> 自动矢量化的基本原理</h2><p>通过编译器分析，我们可以自动找出哪些循环中的操作可以被矢量化。在分析后，发现操作之间没有数据依赖，且可以被SIMD指令集支持的情况下，编译器就可以将这个循环转换为矢量操作。</p>`,9);function _(v,m){const s=p("RouterLink");return o(),e("div",null,[r,k,a("p",null,[n("自动矢量化非常依赖准确的别名分析，因为矢量化需要保证循环中的操作之间没有数据依赖。在实际编译器中，别名分析的准确性往往是一个问题，因此自动矢量化的效果也很难保证。 如果您还不了解别名分析，请参考"),c(s,{to:"/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/2.%E4%B8%AD%E7%AB%AF/(6)%E5%88%AB%E5%90%8D%E5%88%86%E6%9E%90.html"},{default:l(()=>[n("别名分析")]),_:1}),n(" 一节。")]),d])}const h=t(u,[["render",_],["__file","(8)自动矢量化.html.vue"]]);export{h as default};
