import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as n,f as i}from"./app-7fdc7960.js";const o={},r=i('<h1 id="llvm函数的调用时声明插入" tabindex="-1"><a class="header-anchor" href="#llvm函数的调用时声明插入" aria-hidden="true">#</a> LLVM函数的调用时声明插入</h1><p>如果调用一个未声明的函数，我们知道肯定是不正确的，但符号表中，可能预先存有该函数的 FunctionType，这时即使未扫描到该函数，我们也可以用Module中的getOrInsertFunction方法，获取或插入一个函数。</p><p>Constant * Module::getOrInsertFunction ( StringRef Name, FunctionType * T, AttributeSet AttributeList )</p><p>其行为是这样的：</p><ol><li>如果不存在，创建一个原型</li><li>存在，但是一个static的局部函数，那么创建一个新的全局函数替换之</li><li>存在，而且类型正确，返回当前函数</li><li>存在，类型不匹配，那么会在外层包一个constantexpr cast的语句，转换到正确的类型上</li></ol><p>是不是很方便呢？ 这样应该可以减少一次函数的声明遍历。</p>',6),c=[r];function l(_,a){return e(),n("div",null,c)}const d=t(o,[["render",l],["__file","LLVM函数的调用时声明插入.html.vue"]]);export{d as default};
