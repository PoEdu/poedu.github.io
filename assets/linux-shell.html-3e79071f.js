import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{o as e,c as s,f as n}from"./app-7fdc7960.js";const d={},t=n(`<h1 id="linux-shell-极速教程" tabindex="-1"><a class="header-anchor" href="#linux-shell-极速教程" aria-hidden="true">#</a> Linux Shell 极速教程</h1><p>Linux 作为一款超流行的操作系统，Shell的易用性和组合型功不可没。Linux的哲学就是每一个工具只做一件事，把这件事做好，然后通过shell把功能组合起来。这样脚本就能够将大量的工作自动化。</p><p>Linux下的shell主要有sh, csh, bash, zsh, fish等几种。由于fish有着特殊的文法，我这里就主要接受bash/zsh系列的经典shell用法以及技巧。</p><h2 id="了解的你的shell" tabindex="-1"><a class="header-anchor" href="#了解的你的shell" aria-hidden="true">#</a> 了解的你的Shell</h2><p>shell是一种解释型语言，你可以调用其解释器来解析某个shell脚本。一般在Linux下，正在使用的shell会导出变量名<code>$SHELL</code>，你可以打开默认命令行，通过打印这个变量来查看系统默认的shell解释器：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">echo</span> <span class="token environment constant">$SHELL</span>
/bin/zsh
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当然，如果在脚本中，那当前运行着的也许是非默认shell，比如某个程序调用你的脚本，但其配置使用的是自己的bash，这也是可能的，所以如果想检测当前命令是什么，打印<code>$0</code>是一个不错的选择:</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">echo</span> <span class="token variable">$0</span>
<span class="token function">bash</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这里<code>$0</code>表示的是命令行参数中的0号元素，其实就是调用的命令，在Linux中，命令行参数一般由一个数组构成，就是一般你写C语言时，<code>main</code>函数的参数:</p><div class="language-C line-numbers-mode" data-ext="C"><pre class="language-C"><code>int main(int argc, char** argv) 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>命令行参数在shell中也一样，你可以用<code>$0</code>~<code>$N</code>来获取这些参数，全部是字符串：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/usr/bin/echo hello world <span class="token number">123</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>你会得到如下的一个列表:</p><table><thead><tr><th>$0</th><th>$1</th><th>$2</th><th>$3</th></tr></thead><tbody><tr><td>/usr/bin/echo</td><td>hello</td><td>world</td><td>123</td></tr></tbody></table><p>但如果你要用bash运行一个脚本时则不一样了，比如你运行如下指令，这时被执行的代码<code>./script.sh</code>就成为了<code>$0</code>：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>/usr/bin/bash ./script.sh hello world <span class="token number">123</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><table><thead><tr><th>$0</th><th>$1</th><th>$2</th><th>$3</th></tr></thead><tbody><tr><td>./script.sh</td><td>hello</td><td>world</td><td>123</td></tr></tbody></table><h2 id="获取脚本的当前存放位置" tabindex="-1"><a class="header-anchor" href="#获取脚本的当前存放位置" aria-hidden="true">#</a> 获取脚本的当前存放位置</h2><p>我们写脚本一般是为了将某些工作自动化，比如我们想给我们的开源软件写一个发布脚本，功能是编译并创建编译后的软件包。我们可以先检测一下系统有没有构建工具和依赖的软件，如果没有，则提示错误，接下来编译，运行测试，最后打包。</p><p>这样的脚本显然应该放到代码仓库里，然而我们运行脚本的当前目录往往是不确定的，但脚本却要去找到代码仓库的目录，或者说想知道脚本自己放到了哪。这时我们就可以用<code>$0</code>进行一个相对跳转来获取目录：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token assign-left variable">SCRIPTPATH</span><span class="token operator">=</span><span class="token string">&quot;$( cd &quot;<span class="token variable"><span class="token variable">$(</span><span class="token function">dirname</span> <span class="token string">&quot;<span class="token variable">$0</span>&quot;</span><span class="token variable">)</span></span>&quot;</span> <span class="token operator">&gt;</span>/dev/null <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span><span class="token file-descriptor important">&amp;1</span> <span class="token punctuation">;</span> <span class="token builtin class-name">pwd</span> <span class="token parameter variable">-P</span> <span class="token punctuation">)</span>&quot;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个获取思路是，由于一个脚本是由类似<code>/usr/bin/bash ./path/script.sh</code>这样的命令调用的，那么<code>$0</code>里就包含了脚本的相对位置信息，那么我们先用<code>cd</code>跳转到脚本所在目录，再运行<code>pwd</code>获取目录的路径就可以了。</p><h2 id="启动异常时中断" tabindex="-1"><a class="header-anchor" href="#启动异常时中断" aria-hidden="true">#</a> 启动异常时中断</h2><p>在一个bash脚本中，当你在运行一系列指令时，默认是会依次运行所有指令的。 但有时你希望出错时能立即停下来，比如如果测试失败，则不继续执行下面指令去打包编译好的代码。这时，你可以通过如下设置来让出错后立即中断脚本：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token builtin class-name">set</span> <span class="token parameter variable">-e</span>

command1
command2
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>设置<code>-e</code>后，如果<code>command1</code>返回非0值，则<code>command2</code>不会执行。</p><h2 id="输出流重定向" tabindex="-1"><a class="header-anchor" href="#输出流重定向" aria-hidden="true">#</a> 输出流重定向</h2><table><thead><tr><th>重定向类型</th><th>命令格式</th></tr></thead><tbody><tr><td>标准输出流</td><td>run command &gt; output.log</td></tr><tr><td>标准异常流</td><td>run command &gt; error.log</td></tr><tr><td>重定向两者到同一个文件</td><td>run command &gt; out_and_err.log 2&gt;&amp;1</td></tr></tbody></table>`,28),l=[t];function i(r,c){return e(),s("div",null,l)}const p=a(d,[["render",i],["__file","linux-shell.html.vue"]]);export{p as default};
