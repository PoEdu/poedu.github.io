import{_ as d}from"./plugin-vue_export-helper-c27b6911.js";import{r as e,o as t,c as s,a as r,w as h,f as o}from"./app-7fdc7960.js";const c={},i=o('<h1 id="图-graph" tabindex="-1"><a class="header-anchor" href="#图-graph" aria-hidden="true">#</a> 图（Graph）</h1><p>图(Graph)是由顶点的有穷非空集合和顶点之间的集合组成，通常表示为<code>G(V,E)</code>，其中<code>G</code> 表示一个图，<code>V</code>是图<code>G</code>中顶点的集合，<code>E</code>是图<code>G</code>中边的集合。在描绘一张图的时候，通常用一组点或小圆圈表示节点，其间的边则使用直线或曲线。</p><p>试一试，在下面这个图中，添加一些顶点和边。</p>',3),p=o('<p>图中的边可以是有方向或没有方向的，有方向的称为<strong>有向图</strong>，没有方向的称为<strong>无向图</strong>。上面的图有箭头表示，是有向图。有时，图上的边会存在权重，用来表示，路程、花费、时间等。这种被称为<strong>加权图</strong>。</p><h2 id="图论在编译中的应用" tabindex="-1"><a class="header-anchor" href="#图论在编译中的应用" aria-hidden="true">#</a> 图论在编译中的应用</h2><p>图论在编译中的应用非常广泛，比如，编译器的词法分析阶段，就是使用<strong>有限状态自动机</strong>来实现的。有限状态自动机可以看作是一种特殊的有向图。对于函数内各种分支循环构成的代码运行结构，我们一般构建<strong>控制流图</strong>来表示。我们在追踪程序中的函数调用时，往往喜欢用<strong>调用图</strong>来表示。在寄存器分配时，<strong>图着色算法</strong>也是一种图论算法。在代码优化时，可以使用<strong>数据流分析</strong>，来分析程序中的数据流，这也是一种图论算法。</p><h2 id="图的表示法" tabindex="-1"><a class="header-anchor" href="#图的表示法" aria-hidden="true">#</a> 图的表示法</h2><h3 id="邻接矩阵" tabindex="-1"><a class="header-anchor" href="#邻接矩阵" aria-hidden="true">#</a> 邻接矩阵</h3><p><strong>邻接矩阵</strong>是一种常见的表示图的方法，使用一个二维表，行列都是定点的编号。如果两个顶点之间存在边，则在对应的行列位置上标记为<code>1</code>或者对应权重，否则标记为<code>0</code>。</p><p>这种方式简单直观，并且对于无向图，邻接矩阵是对称的。但是，对于稀疏图，邻接矩阵会浪费大量的空间，因为其大部分的位置都是<code>0</code>。</p><h3 id="邻接表" tabindex="-1"><a class="header-anchor" href="#邻接表" aria-hidden="true">#</a> 邻接表</h3><p><strong>邻接表</strong>是一种更加节省空间的表示图的方法，它使用一个数组，数组中的每个元素都是一个链表，链表中存储了与该顶点相邻的顶点。</p><h3 id="边表" tabindex="-1"><a class="header-anchor" href="#边表" aria-hidden="true">#</a> 边表</h3><p><strong>边表</strong>则是一种以边为中心的表示图的方法，它使用一个数组，数组中的每个元素都是一条边，边中存储了起点和终点的顶点编号，以及权重等信息。一般边表需要排序或建立索引，以便快速查找哪些定点与某个顶点相邻。在数据库中存储图结构，如用户的好友、关注关系等，就十分常用这种表示方法。</p><h2 id="拓扑排序" tabindex="-1"><a class="header-anchor" href="#拓扑排序" aria-hidden="true">#</a> 拓扑排序</h2><p>有些图会有一些特殊的性质，比如，有向无环图（DAG）就是一种特殊的图，它的顶点之间存在有向边，但是不存在环。这种图的一个重要性质是，它的顶点可以被线性排序，使得对于所有的有向边<code>(u,v)</code>，都有<code>u</code>在<code>v</code>之前。这种排序被称为<strong>拓扑排序</strong>。</p><p>拓扑排序的应用非常广泛，最常见的是在构建系统中，我们需要对各个模块进行编译，但是，有些模块之间存在依赖关系，比如，模块<code>A</code>依赖于模块<code>B</code>，那么，我们就需要先编译模块<code>B</code>，再编译模块<code>A</code>。如果我们将各个模块看作图中的顶点，模块之间的依赖关系看作有向边，那么，我们就可以使用拓扑排序来确定编译的顺序。</p><h2 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历" aria-hidden="true">#</a> 图的遍历</h2><p>图的遍历方式有两种，一种是<strong>深度优先遍历</strong>，另一种是<strong>广度优先遍历</strong>。</p><h2 id="最小生成树" tabindex="-1"><a class="header-anchor" href="#最小生成树" aria-hidden="true">#</a> 最小生成树</h2><p>最小生成树问题是图论中的一个经典问题，它的目标是在一个加权连通图中找到一个生成树，使得树上所有边的权值之和最小。</p><p>最小生成树问题有两种经典的算法，一种是<strong>Prim算法</strong>，另一种是<strong>Kruskal算法</strong>。</p><h2 id="最短路径" tabindex="-1"><a class="header-anchor" href="#最短路径" aria-hidden="true">#</a> 最短路径</h2><p>最短路径问题是图论中的另一个经典问题，它的目标是在一个加权连通图中找到两个顶点之间的最短路径。</p><p>最短路问题分为<strong>单源最短路</strong>和<strong>多源最短路</strong>，单源最短路是指从一个顶点到其他所有顶点的最短路径，多源最短路是指任意两个顶点之间的最短路径。</p><p>对于单源最短路问题，有两种经典的算法，一种是<strong>Dijkstra算法</strong>，另一种是<strong>Bellman-Ford算法</strong>。</p><p>对于多源最短路问题，有一种经典的算法，叫做<strong>Floyd算法</strong>。</p><h2 id="图着色算法" tabindex="-1"><a class="header-anchor" href="#图着色算法" aria-hidden="true">#</a> 图着色算法</h2><p>图着色算法是一种经典的图论算法，它的目标是给图中的每个顶点分配一个颜色，使得相邻的顶点颜色不同。这种算法在寄存器分配时，非常有用。图着色算法简单实现可以用贪心算法来做，但是，贪心算法并不能保证得到最优解。</p>',26);function g(l,_){const a=e("Graph"),n=e("ClientOnly");return t(),s("div",null,[i,r(n,null,{default:h(()=>[r(a)]),_:1}),p])}const x=d(c,[["render",g],["__file","图.html.vue"]]);export{x as default};
